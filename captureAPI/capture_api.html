<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Sniffer Capture API</title>
    <style>
      body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
        font-family: Roboto, Helvetica, Arial, sans-serif;
        font-size: 16px;
        }
      h1, h2, h3, h4, h5, h6 {
        margin-top: 24px;
        margin-bottom: 16px;
        font-weight: 400;
        line-height: 1.25;
        }
      h1 { margin-top: 0; }
      h1 { font-size: 3em;    background: #ace; }
      h2 { font-size: 2.25em; background: #ace; }
      h3 { font-size: 1.75em; background: #ace; }
      h4 { font-size: 1.25em; background: #ace; }
      h5 { font-size: 1.00em; background: #eee; }
      code { font-size: 1em; font-weight:bold; }

    </style>
  </head>

  <body>
<h1 id="capture-api">Capture API</h1>
<p>The components of the <em>Capture API</em> interface are:</p>
<ul>
<li>the API library: <em>libminisniff.dll</em> or <em>libminisniff.so</em></li>
<li>API documentation: <em>libminisniff.h</em>.
API function descriptions are included with the C declarations.</li>
<li>minisniff.py, an example Python program that uses the API.</li>
</ul>
<h2 id="example-program">Example Program</h2>
<p>The essence of minisniff.py is shown here:</p>
<pre><code>buff = create_string_buffer(256)
rv = mini.version(buff, sizeof(buff))
print(&#39;Using library version: %s\n&#39; % repr(buff.value))

# beeps from your computer as drivers are loaded :)
sniffer = c_int(mini.sniffInit())

# loop while waiting for the OS to do its thing
snifferStatus = E_SNIFFER_NOT_FOUND
for i in range(0, 6):
  stat = c_int(mini.getHardwareStatus(sniffer))
  snifferStatus = stat.value
  if snifferStatus != E_SNIFFER_NOT_FOUND:
    break
  time.sleep(1)

if snifferStatus != INIT_OK:        # probably timed out
  print(&#39;problem !!!!&#39;)
  mini.sniffEnd(sniffer)
  return

rv = mini.getSerial(sniffer, buff, sizeof(buff))
print(&#39;Serial string: %s\n&#39; % repr(buff.value))

# here when the sniffer is found OK
# disconnect
mini.setConnect(sniffer, 0)
needed = 16 * 1024                  # easily covers setup
mini.setNeeded(sniffer, needed)
# reconnect and run
mini.setRun(sniffer, 1)

# loop until finished
while True:
  done = mini.getDone(sniffer)
  cc   = mini.getCaptureCount(sniffer)
  dc   = mini.getDecodedCount(sniffer)
  print(cc, &#39;/&#39;, dc, sep=&#39;&#39;)
  if done:
    break
  time.sleep(2)

# get packet data plus decoded transactions, etc.
lineCount = mini.getPacketDataRowCount(sniffer)
print(lineCount, &#39;decoded rows&#39;)

ofile = open(&#39;pyoutput.txt&#39;, &#39;w&#39;)
# a huge buffer..
rowBuf = create_string_buffer(10 * 1024)

for i in range(0, lineCount):
  mini.getPacketDataRow(sniffer, i, rowBuf, sizeof(rowBuf))
  # decoded rows are terminated with \n\0
  # now you can split the data, analyze it any way you want...
  # this program just writes out a file
  ofile.write(rowBuf.value)

ofile.close()

mini.sniffEnd(sniffer)
</code></pre><h4 id="remarks-">Remarks:</h4>
<ul>
<li>initializing the miniSniffer (sniffInit) involves finding and opening the miniSniffer board</li>
<li>when a capture is started (setRun) a flag is set in a separate thread which updates its
progress via the getDone() flag.
The program must sleep until this signals <em>true</em>.</li>
<li>final output is a set of text rows, as documented below.</li>
</ul>
<h2 id="api">API</h2>
<p>The API is defined in minisniff.h.</p>
<p>Boolean values for true and false vary between languages.
Regular integers are used for booleans:</p>
<pre><code>0: false
not 0: true
</code></pre><p>sniffHandle is a C void* value.
In other languages this could be represented as an integer,
unsigned if available.</p>
<p>Strings are C char* values,
null-terminated sequences of ASCII characters.</p>
<h4 id="version">Version</h4>
<h5 id="unsigned-version-char-outstr-unsigned-outlen-">unsigned version(char *outStr, unsigned outLen);</h5>
<p>If outLen is large enough, copies the version string to the outStr buffer.
Otherwise, outStr is unchanged.</p>
<p>returns: The length of the version string including a terminating null.</p>
<p>example version string: <code>libminisniff DLL/SO,Feb 27 2019,18:42:03</code></p>
<h4 id="initialize-and-terminate">Initialize and terminate</h4>
<h5 id="sniffhandle-sniffinit-">sniffHandle sniffInit();</h5>
<p>returns: a handle that can be used to query and control the sniffer hardware
and software.
It also starts a background thread that will be attempting to connect to
the sniffer hardware, but it does not mean that the software has succeeded
(or failed) in opening the hardware.
See also <code>getHardwareStatus()</code></p>
<h5 id="void-sniffend-sniffhandle-h-">void sniffEnd(sniffHandle h);</h5>
<p>Closes the connection to the sniffer board.
Pass-through connected/disconnected status is not changed.</p>
<h5 id="unsigned-getserial-sniffhandle-h-char-outstr-unsigned-outlen-">unsigned getSerial(sniffHandle h, char *outStr, unsigned outLen);</h5>
<p>If outLen is large enough, copies the serial string to the outStr buffer.
Otherwise, outStr is unchanged.</p>
<p>returns: The length of the serial string including a terminating null.</p>
<p>example serial string: <code>BU2ABCDEFG</code></p>
<h5 id="int-gethardwarestatus-sniffhandle-h-">int getHardwareStatus(sniffHandle h);</h5>
<p><code>sniffInit()</code> starts a background process that repeatedly attempts
to connect to the sniffer hardware.
At the time of writing, a failed connection is retried every second.</p>
<p>This function queries the success or failure of the background process.
Return codes are:</p>
<pre><code>INIT_OK                       =  0
E_SNIFFER_NOT_FOUND           = -1
E_CANNOT_CONFIGURE_HARDWARE   = -2
E_SNIFFER_LICENSE_INVALID     = -3
E_NOT_INITIALIZED             = -4
E_BUFFER_ALLOCATION_FAILED    = -5
</code></pre><h5 id="int-gethardwarechanged-sniffhandle-h-">int getHardwareChanged(sniffHandle h);</h5>
<p>This is a boolean function that reports any change in the hardware status.
Calling this function returns the <code>changed</code> status and automatically clears
the status to false (false = 0).</p>
<p>A GUI program will typically call <code>getHardwareStatus()</code> from its main loop.</p>
<h4 id="connect-and-disconnect">Connect and Disconnect</h4>
<h5 id="void-setconnect-sniffhandle-h-int-boolval-">void setConnect(sniffHandle h, int boolVal);</h5>
<p>Connects or disconnects the link between the sniffer&#39;s Host and Device
sockets.
Typical use is to disconnect before a data capture;
the capture logic will then reconnect so that startup packets are captured.</p>
<h4 id="run-and-stop">Run and Stop</h4>
<h5 id="void-setneeded-sniffhandle-h-unsigned-v-">void setNeeded(sniffHandle h, unsigned v);</h5>
<p>Set the capture size in compressed bytes.
If needed, the value will be reduced at run time to the maximum possible.</p>
<h5 id="void-setrun-sniffhandle-h-int-boolval-">void setRun(sniffHandle h, int boolVal);</h5>
<p>This function sets a flag that is periodically inspected by a background
thread when it is idling.
Setting the flag to <code>true</code> fires off a data acquisition.
Setting the flag to <code>false</code> has no effect.</p>
<h5 id="int-getrun-sniffhandle-h-">int getRun(sniffHandle h);</h5>
<p>Returns the state of the internal <code>run</code> flag.</p>
<h5 id="void-setstop-sniffhandle-h-int-boolval-">void setStop(sniffHandle h, int boolVal);</h5>
<p>This function sets a flag that is periodically inspected by a background
thread when it is running a data acquisition.
Setting the flag to <code>true</code> terminates the acquisition.
Setting the flag to <code>false</code> has no effect.</p>
<h5 id="int-getstop-sniffhandle-h-">int getStop(sniffHandle h);</h5>
<p>Returns the state of the internal <code>stop</code> flag.</p>
<h4 id="get-progress">Get Progress</h4>
<h5 id="int-getdone-sniffhandle-h-">int getDone(sniffHandle h);</h5>
<p>When <code>run</code> is commanded, background logic will
instruct the sniffer hardware to perform a data capture
and then download the captured data and decompress it.
It then sets a <code>done</code> flag and returns to idle.</p>
<p>This function returns and clears the state of the internal <code>done</code> flag.</p>
<h5 id="unsigned-getcapturecount-sniffhandle-h-">unsigned getCaptureCount(sniffHandle h);</h5>
<p>Returns the number of bytes of compressed data captured by the hardware.</p>
<h5 id="unsigned-getdecodedcount-sniffhandle-h-">unsigned getDecodedCount(sniffHandle h);</h5>
<p>Returns the number of bytes of compressed data downloaded from the
hardware and decoded by the software.</p>
<h4 id="get-captured-data">Get Captured Data</h4>
<h5 id="unsigned-getpacketdatarowcount-sniffhandle-h-">unsigned getPacketDataRowCount(sniffHandle h);</h5>
<p>Captured data is grouped into rows corresponding broadly to packets.
This function returns the row count.</p>
<h5 id="unsigned-getpacketdatarow-sniffhandle-h-unsigned-rowix-char-outstr-unsigned-outlen-">unsigned getPacketDataRow(sniffHandle h, unsigned rowIx, char *outStr, unsigned outLen);</h5>
<p>If outLen is large enough, copies the row to the outStr buffer.
Otherwise, outStr is unchanged.</p>
<p>Returns the length of the row string including a terminating null.</p>
<p>See below for examples of the data rows.</p>
<h2 id="text-row-format">Text Row Format</h2>
<p>Lines starting with &#39;--&#39; are comments.</p>
<p>For CRC decodes, P=Pass, F=Fail.</p>
<p>Fields are split with &#39;;&#39; characters.</p>
<p>Each row starts with an <em>indentation level</em> and is terminated with &quot;\n\0&quot;.
Rows which represent USB packets include the decimal packet type ID;
for instance H:2 because 2 is the ID for a handshake packet.</p>
<p>Times and durations are shown as decimal counts in 12MHz ticks.
i.e. each tick is 1/12 microseconds.</p>
<h3 id="packets">Packets</h3>
<h4 id="k-token-packet">K: Token Packet</h4>
<p>Example: <code>2;K:13;TI:3467647;AD:3;EP:0;5P:0a;TL:5</code></p>
<h4 id="d-data-packet">D: Data Packet</h4>
<p>Example: <code>2;D:11;TI:3468567;DA:4b,00,00;6P:00;TL:5</code></p>
<h4 id="h-handshake-packet">H: Handshake Packet</h4>
<p>Example: <code>2;H:2;TI:3318368;TL:7</code></p>
<h4 id="s-sof-packet">S: SOF Packet</h4>
<p>Example: <code>1;S:5;TI:3070276;FR:1202;5P:1a;TL:11967</code></p>
<h3 id="non-packet-events">Non-packet Events</h3>
<h4 id="y-reset">Y: Reset</h4>
<p>Example: <code>0;Y:Reset;TI:1206414;RL:658533;TL:5239</code></p>
<h3 id="groupings">Groupings</h3>
<h4 id="g-sof-group">G: SOF group</h4>
<p>Example: <code>0;G:SOFgroup;X:33</code></p>
<h4 id="t-transaction">T: Transaction</h4>
<p>Example: <code>1;T:SETUP;X:3</code></p>
<h4 id="c-control-transfer">C: Control Transfer</h4>
<p>Example: <code>0;C:Control;X:4</code></p>
<h3 id="fields">Fields</h3>
<h4 id="x-repetition-count">X: Repetition count</h4>
<p>Example: <code>0;G:SOFgroup;X:33</code>
The count (33 in this case) is in decimal.</p>
<h4 id="5p-crc_5-pass-and-5f-crc5-fail">5P: CRC_5 Pass and 5F: CRC5 Fail</h4>
<p>Example: <code>1;S:5;TI:3070276;FR:1202;5P:1a;TL:11967</code>
The CRC (1a in this case) is in hexadecimal.</p>
<h4 id="6p-crc16-pass-and-6f-crc16-fail">6P: CRC16 Pass and 6F: CRC16 Fail</h4>
<p>Example: <code>2;D:3;TI:1864548;DA:80,06,00,01,00,00,40,00;6P:94dd;TL:5</code>
The CRC (94dd in this case) is in hexadecimal.</p>
<h4 id="ad-address">AD: Address</h4>
<p>Example: <code>2;K:9;TI:2437451;AD:5;EP:0;5P:1a;TL:5</code>
The Address (5 in this case) is in decimal.</p>
<h4 id="da-data">DA: Data</h4>
<p>Example: <code>2;D:11;TI:3468567;DA:4b,00,00;6P:00;TL:5</code>
The data values are comma separated hexadecimal values.</p>
<h4 id="ep-endp">EP: Endp</h4>
<p>Example: <code>2;K:9;TI:2593006;AD:5;EP:0;5P:1a;TL:5</code>
The Endpoint (0 in this case) is in decimal.</p>
<h4 id="fr-frame">FR: Frame</h4>
<p>Example: <code>0;S:5;TI:2484305;FR:1165;5P:16;TL:7</code>
The Frame number (1165 in this case) is in decimal.</p>
<h4 id="rl-reset-length">RL: Reset length</h4>
<p>Example: <code>0;Y:Reset;TI:1249543;RL:180095;TL:10645</code>
The decimal Reset Length (180095 in this case) is a count in 12MHz ticks.</p>
<h4 id="ti-tick">TI: Tick</h4>
<p>Example: <code>1;S:5;TI:1824315;FR:1110;5P:11;TL:11967</code>
The decimal Start Time (1824315 in this case) for this packet or event in 12MHz ticks.</p>
<h4 id="tl-tail-length">TL: Tail length</h4>
<p>Example: <code>2;H:10;TI:2522009;TL:67</code>
The decimal Idle Time (67 in this case) after the packet is a count in 12MHz ticks.</p>
</body></html>
